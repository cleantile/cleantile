<!--
  @license
  Copyright (c) 2016 Ryan Leonard.  All rights reserved.
  This code may only be used under the MIT style license found at http://github.com/cleantile/cleantile/LICENSE
--><!--
  This HTML was compiled from [Blade] source code.  Please edit the Blade file instead of the HTML.
  Most Blade files are in the same directory as the compiled HTML file.

  [Blade]: https://github.com/bminer/node-blade
--><link rel="import" href="../../polymer/polymer.html"/><link rel="import" href="../drag-behavior/cleantile-drag-behavior.html"/><!--
`<cleantile-split>` divides the window into two different regions that can hold either `<cleantile-split>` or
[`<cleantile-pane>`](#cleantile-pane) elements.

    <cleantile-split direction="horizontal">
      <cleantile-pane>
        <file-editor file="README.md" syntax="markdown"></file-editor>
        <file-editor file="LICENSE" syntax="text"></file-editor>
      </cleantile-pane>
      <cleantile-pane>
        <file-editor file="README.md" syntax="markdown"></file-editor>
        <file-editor file="LICENSE" syntax="text"></file-editor>
      </cleantile-pane>
    </cleantile-split>

@demo demo/split.compiled.html Split Demo
 --><dom-module id="cleantile-split"><template><style type="text/css">
:host,
#contents {
  display: block;
  width: 100%;
  height: 100%;
}
#contents {
  position: relative;
}
:host #contents ::content > cleantile-pane {
  position: absolute;
}
:host[direction="vertical"] #contents ::content > cleantile-pane {
  width: 100%;
  height: 50%;
  left: 0;
}
:host[direction="vertical"] #contents ::content > cleantile-pane:first-of-type {
  top: 0;
}
:host[direction="vertical"] #contents ::content > cleantile-pane:last-of-type {
  bottom: 0;
}
:host:not([direction="vertical"]) #contents ::content > cleantile-pane {
  width: 50%;
  height: 100%;
  top: 0;
}
:host:not([direction="vertical"]) #contents ::content > cleantile-pane:first-of-type {
  left: 0;
}
:host:not([direction="vertical"]) #contents ::content > cleantile-pane:last-of-type {
  right: 0;
}

</style><div id="contents"><content></content></div></template><script type="text/javascript">
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Polymer({
    is: "cleantile-split",
    properties: {

      /**
Determines if the elements are nested above each other (`vertical`) or next to each other (`horizontal`).
Defaults to `horizontal`.
       */
      direction: {
        type: String,
        value: "horizontal",
        reflectToAttribute: true,
        observer: "_directionChanged"
      },

      /**
Marks that the two sides of this split can't be merged together.

```html
<cleantile-split direction="horizontal" no-merge>
  <cleantile-pane> <file-browser /> </cleantile-pane>
  <cleantile-split direction="vertical">
    <cleantile-pane> <file-editor /> </cleantile-pane>
    <cleantile-pane> <file-editor /> </cleantile-pane>
  </cleantile-split>
</cleantile-split>
```

In this example, the file browser and the file editors can't be merged together, but the top/bottom file editors
can be merged together.
       */
      "no-merge": {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
Sets the division point between the two elements.

Must be a number ending in "%" or "px".  Defaults to "50%".
If negative, `boundary` is calculated from the far (right or bottom) side of the split.
       */
      boundary: {
        type: String,
        value: "50%",
        reflectToAttribute: true,
        observer: "_boundaryChanged"
      },

      /**
Sets the minimum division point between the two elements, measured from the closer (left or top) side of the
split.

Must be `"null"`, or a number ending in "%" or "px".
Defaults to `"null"`.
       */
      "min-boundary": {
        type: String,
        value: "null",
        reflectToAttribute: true,
        observer: "_minBoundaryChanged"
      },

      /**
Sets the maximum division point between the two elements, measured from the closer (left or top) side of the
split.

Must be `"null"`, or a number ending in "%" or "px".
Ignored if `max-boundary` is smaller than `min-boundary`.
Defaults to `"null"`.
       */
      "max-boundary": {
        type: String,
        value: "null",
        reflectToAttribute: true,
        observer: "_maxBoundaryChanged"
      }
    },

    /**
Find a `<cleantile-drag>` inside this split, if one exists.
@return {HTMLElement} returns the `<cleantile-drag>` element, if one exists.
     */
    dragger: function() {
      var child, children, i, len, ref;
      if (!(children = this.$.contents.children)) {
        return;
      }
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (child.behaviors && child.behaviors.length) {
          if (ref = window.CleanTile.DragBehavior, indexOf.call(child.behaviors, ref) >= 0) {
            return child;
          }
        }
      }
      return null;
    },

    /**
Find a `<cleantile-split>` or `<cleantile-pane>` inside this split, if it exists.
@param {Boolean} second if `true`, find the second (right/bottom) item.  Defaults to `false`.
@return {HTMLElement} returns the split/pane element, if one exists.
     */
    child: function(second) {
      var child, children, i, len, ref;
      if (second == null) {
        second = false;
      }
      if (second === 1) {
        second = false;
      }
      if (!(children = this.$.contents.children)) {
        return;
      }
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (!((ref = child.tagName.toLowerCase()) === "cleantile-split" || ref === "cleantile-pane")) {
          continue;
        }
        if (second) {
          second = false;
          continue;
        }
        return child;
      }
      return null;
    },

    /**
If the boundary is set in pixels, it needs to be updated if the size of the split changed.
Also, if the size has changed, update children in the split who have an `updateSize` function.
@param [Object] opts optionally provide details about which dimensions changed to optimize updates.
@option opts [Boolean] width `true` if the width of the parent element remained the same
@option opts [Boolean] height `true` if the height of the parent element remained the same
     */
    updateSize: function(opts) {
      var changed, child, height, i, len, ref, results, width;
      changed = this.parsePx(this.boundary) && !(this.direction === "horizontal" && opts && opts.width === true) && !(this.direction !== "horizontal" && opts && opts.height === true);
      if (changed) {
        this.setPx();
      }
      width = (opts && opts.width) || this._lastSize && this._lastSize.width && this._lastSize.width === this.offsetWidth;
      height = (opts && opts.height) || this._lastSize && this._lastSize.height && this._lastSize.height === this.offsetHeight;
      if (width && height) {
        return;
      }
      this._lastSize = {
        width: this.offsetWidth,
        height: this.offsetHeight
      };
      ref = this.$.contents.children;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if (typeof child.updateSize === "function") {
          results.push(child.updateSize({
            width: width,
            height: height
          }));
        }
      }
      return results;
    },

    /*
    Returns a human-readable interpretation of this element's name.
    @return [String]
     */
    printTag: function() {
      if (this.is) {
        return "<" + this.is + ">";
      } else {
        return "<cleantile-split>";
      }
    },

    /*
    Checks the validity of a parameter that can be given as a pixel value, and parse it into a number.
    @param [Any] val the value to check
    @return [Number, Boolean] `false` if the value is invalid.  Otherwise, returns the parsed number.
     */
    parsePx: function(val) {
      var num, valid;
      valid = val && typeof val === "string" && val.slice(-2) === "px" && (num = parseFloat(val.slice(0, -2))) && !isNaN(num);
      if (valid) {
        return num;
      } else {
        return false;
      }
    },

    /*
    Checks the validity of a parameter that can be given as a percent, and parses it into a number.
    @param [Any] val the value to check
    @return [Number, Boolean] `false` if the value is invalid.  Otherwise, returns the parsed number.
     */
    parsePercent: function(val) {
      var num, valid;
      valid = val && typeof val === "string" && val.slice(-1) === "%" && (num = parseFloat(val.slice(0, -1))) && !isNaN(num) && num < 100 && num > -100;
      if (valid) {
        return num;
      } else {
        return false;
      }
    },

    /*
    Updates the size of the children panes, if the size is in percent.
     */
    setPercent: function() {
      var dir, el, left, ref, right;
      left = this.parsePercent(this.boundary);
      right = 100 - Math.abs(left);
      if (left < 0) {
        ref = [right, Math.abs(left)], left = ref[0], right = ref[1];
      }
      dir = this.direction === "horizontal" ? "width" : "height";
      if (el = this.child(1)) {
        el.style[dir] = left + "%";
      }
      if (el = this.child(2)) {
        return el.style[dir] = right + "%";
      }
    },

    /*
    Updates the size of the chlidren panes, if the size is in pixels.
     */
    setPx: function() {
      var Dir, dir, el, left, ref, right;
      left = this.parsePx(this.boundary);
      Dir = this.direction === "horizontal" ? "Width" : "Height";
      dir = Dir.toLowerCase();
      right = this.$.contents["client" + Dir] - Math.abs(left);
      if (left < 0) {
        ref = [right, Math.abs(left)], left = ref[0], right = ref[1];
      }
      if (el = this.child(1)) {
        el.style[dir] = left + "px";
      }
      if (el = this.child(2)) {
        return el.style[dir] = right + "px";
      }
    },

    /*
    Observer for `direction` attribute.  Updates needed children, and redraws.
     */
    _directionChanged: function(direction) {
      var dragger;
      if ((dragger = this.dragger()) && dragger.set) {
        dragger.set("direction", direction);
      }
      return this.updateSize();
    },

    /*
    Observer for `boundary` attribute.
    Checks that the boundary given is valid, then resizes the contents of this split.
     */
    _boundaryChanged: function(next, last) {
      var dragger;
      if (!(this.parsePx(next) || this.parsePercent(next))) {
        if (last && last !== next && (this.parsePx(last) || this.parsePercent(last))) {
          console.warn("'" + next + "' is an invalid 'boundary' value for " + (this.printTag()) + ".  Reverting to '" + last + "'.");
          this.set("boundary", last);
        } else {
          console.warn("'" + next + "' is an invalid 'boundary' value for " + (this.printTag()) + ".  Defaulting to '50%'.");
          this.set("boundary", "50%");
        }
        return;
      }
      if ((dragger = this.dragger()) && dragger.set) {
        dragger.set("boundary.val", next);
      }
      if (this.parsePercent(next)) {
        return this.setPercent();
      } else if (this.parsePx(next)) {
        return this.setPx();
      }
    },
    _minBoundaryChanged: function(val) {
      var dragger;
      if ((dragger = this.dragger()) && dragger.set) {
        return dragger.set("boundary.min", val);
      }
    },
    _maxBoundaryChanged: function(val) {
      var dragger;
      if ((dragger = this.dragger()) && dragger.set) {
        return dragger.set("boundary.max", val);
      }
    }
  });

}).call(this);

</script></dom-module>